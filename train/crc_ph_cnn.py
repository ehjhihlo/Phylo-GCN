# -*- coding: utf-8 -*-
"""CRC_Ph-CNN

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n_UmfyqngjHvwh7D4Cy-v63TzhvCMWfA
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import math
import seaborn as sns
from sklearn import datasets
from sklearn import metrics
from sklearn.preprocessing import LabelBinarizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, roc_auc_score, f1_score, precision_score, recall_score
import os
import keras as K
import tensorflow as tf
from tensorflow.keras import datasets, layers, models
os.environ['TF_CPP_MIN_LOG_LEVEL']= '2'

# !gdown --id '1S9iwczSf6KL5jMSmU20SXKCSD3BUx4o_' --output level-6.csv #GMPR_genus
!gdown --id '1q0yp1iM66BKvqee46bOuSZYwl_SJCTp0' --output level-6.csv #GMPR_species

train = pd.read_csv("level-6.csv")
train.head()
train.info()

from sklearn.preprocessing import LabelEncoder
labelencoder = LabelEncoder()
train["Diagnosis"] = labelencoder.fit_transform(train["Diagnosis"])
# test["Diagnosis"] = labelencoder.fit_transform(test["Diagnosis"])
# for i in range(len(train)):
#     if train["Diagnosis"][i] == 'Cancer':
#         train["Diagnosis"][i] = str(1)
#     else:
#         train["Diagnosis"][i] = str(0)
train

not_select = ["index", "Diagnosis"]
train_select = train.drop(not_select,axis=1)
df_final_select = train_select

"""#Ph-CNN
##reference:
###https://github.com/dfioravanti/phylogenetic-cnn
###https://www.tensorflow.org/tutorials/images/cnn

##Import coordinate data
"""

# !gdown --id '1twQxfPShnt05CwJl8fY9Q9YxHnq0XNq_' --output ordinate.csv #GMPR
!gdown --id '1UHfMq8742mRthqrMSZKPYQmgEgt9Lu6q' --output ordinate.csv #GMPR
C = pd.read_csv("ordinate.csv")

C.head()

not_select=['index','PC442','PC443']
C_final = C.drop(not_select,axis=1)
C_final.info()
C_final.head()
X_final = pd.concat([df_final_select, C_final], axis=1)
print(X_final.shape)
x = X_final
y = train['Diagnosis']

train_x, test_x, train_y, test_y = train_test_split(x,y,test_size=0.2,random_state=0)
train_x = train_x.values.reshape(354, 2, 263, 3)
train_x = train_x.reshape(354, 2, 263, 3)
test_x = test_x.values.reshape(89, 2, 263, 3)
test_x = test_x.reshape(89, 2, 263, 3)
train_x = tf.image.resize(train_x, (128, 128))
test_x = tf.image.resize(test_x, (128, 128))

"""## Model"""

#group1
model = K.models.Sequential()
model.add(K.layers.Conv2D(3, (3, 3), activation='relu', input_shape=train_x.shape[1:]))
model.add(K.layers.Conv2D(20, (3, 3), activation='relu', input_shape=train_x.shape[1:]))
model.add(K.layers.MaxPooling2D((2, 2)))
model.add(K.layers.Flatten())
model.add(K.layers.BatchNormalization(axis=1, momentum=0.99, epsilon=1e-05, center=True, scale=True))
model.add(K.layers.Dense(12, activation= 'relu'))
model.add(K.layers.BatchNormalization(axis=1, momentum=0.99, epsilon=1e-05, center=True, scale=True))
model.add(K.layers.Dropout(0.15))
model.add(K.layers.Dense(1,activation='sigmoid'))

model.summary()

callback = tf.keras.callbacks.EarlyStopping(monitor='val_loss', patience=5, restore_best_weights=True)
opt = tf.keras.optimizers.Adam(learning_rate=0.0005)
model.compile(optimizer=opt, loss='binary_crossentropy', metrics=['accuracy'])
h2 = model.fit(train_x, train_y, epochs=20, batch_size=6, validation_data=(test_x, test_y), callbacks=[callback])

# summarize history for accuracy
plt.plot(h2.history['accuracy'])
plt.plot(h2.history['val_accuracy'])
plt.title('model accuracy')
plt.ylabel('accuracy')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

# summarize history for loss
plt.plot(h2.history['loss'])
plt.plot(h2.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

y_pred = model.predict(test_x)
# print(y_pred)
for i in range(len(y_pred)):
  if y_pred[i]<0.5:
    y_pred[i] = 0
  else:
    y_pred[i] = 1

mat = confusion_matrix(test_y, y_pred)
sns.heatmap(mat.T, square=True, annot=True, fmt='d', cbar=False)
plt.xlabel('true label')
plt.ylabel('predicted label')
score_recall = recall_score(test_y, y_pred, average=None)
f1score = f1_score(test_y, y_pred, average="macro")
precisionscore = precision_score(test_y, y_pred, average=None)
auc_roc = roc_auc_score(test_y, y_pred)
print("precision = ",precision_score)
print("recall = ",score_recall)
print("auc_roc = ",auc_roc)
print("f1_score = ",f1_score)

with open('Ph-CNN_result.csv','w') as f:
    f.write('Precision_Normal,Precision_Cancer,Recall_Normal,Recall_Cancer,Auc_Score,F1_Score,')
    f.write('\n')
    f.write(str(precisionscore[0])+','+str(precisionscore[1])+','+str(score_recall[0])+','+str(score_recall[1])+','+str(auc_roc)+','+str(f1score))